# 단일 연결 리스트
---
#### 배열의 단점
배열은 연속된 메모리를 할당받아 데이터를 효율적으로 관리할 수 있는 자료구조다. 하지만 배열은 데이터양이 정해져있지 않은 경우에는 비효율적이다. 아래 두가지 경우를 살펴보자.
1. 크기가 10인 배열에 데이터를 11개 넣는 경우
   - 11번째 데이터를 넣을 때 stackoverflow 발생하거나, Collection, STL 같은 라이브러리를 사용한 경우 각자의 방식(1.5 ~ 2배) 으로 크기를 늘린 배열을 새로 생성하고 기존의 배열 데이터를 새로 생성한 배열에 복사한다.
2. 크키가 100인 배열에 데이터 11개를 넣는 경우
   - 89의 크기가 낭비된다. 64비트 환경의 경우 8*89 = 712 byte가 낭비된다.
---
#### Linked list
흔히 연결 리스트, 링크드 리스트라고 불리는 것은 원소 개수를 모르는 경우에 사용하기 적합한 자료형이다.

![basic_single_linked_list](https://he-s3.s3.amazonaws.com/media/uploads/1b76d10.png)
위 이미지에서 4개의 파란색 박스가 각각 구조체(Java : class or 객체 / Python 3.7 @dataclass)다. 5,10,20,1이 들어있는 부분은 데이터가 들어가는 메모리 공간이고, 화살표가 있는 부분은 다음 객체를 가르키는 포인터다. (나의 다음 구조체를 가르킨다.)

왜 리스트가 데이터 개수를 모를때 사용하기 적합한 자료형인지는 아래를 살펴보자.

**배열에서 데이터 추가하는 경우**
- 배열에 여유공간이 있고 마지막에 삽입된 데이터 다음 인덱스에 데이터를 추가하는 경우 (Best)
- 배열에 여유공간이 있고 배열의 제일 앞 또는 중간에 데이터를 추가하는 경우 (추가하려는 위치 바로 다음칸의 데이터들을 한칸씩 뒤로 Copy 하는 작업이 발생)
- 배열에 여유공간이 없는 경우 (더 큰 크기의 배열을 새로 만들고 기존 배열의 값을 새로운 배열에 Copy 후 데이터 추가 작업 실행)

**리스트에서 데이터 추가하는 경우**
위에서 봤던 화살표 부분이 가르키는 구조체를 바꾸기만 하면 된다.
![insert_single_linked_list](https://media.geeksforgeeks.org/wp-content/cdn-uploads/gq/2013/03/Linkedlist_insert_middle.png)
- B와 C사이에 E를 삽입하는 경우
  1. B->C를 가르키는 부분을 B->E 를 가르키게 수정한다.
  2. E는 C를 가르키도록 수정한다.
  3. 끝 ^^!

- D의 뒤에 E를 삽입하는 경우 (제일 뒤)
    1. D->Null을 D->E로 수정한다.
    2. E->Null로 수정한다.
    3. 끝 ^^!


- A의 앞에 E를 삽입하는 경우 (제일 앞)
     1. E->A로 수정한다.
     2. Head -> E로 수정한다.
     3. 끝 ^^!

**리스트에서 데이터 삭제하는 경우**
![delete_single_linked_list](https://i.stack.imgur.com/rVCdE.png)
삭제는 그냥 삭제하고 싶은 구조체의 앞 구조체가 다음 구조체를 가르키도록 하면 된다.

#### Single Linked List (단일 연결 리스트)의 단점
단일 연결 리스트는 방향이 앞에서 뒤로만 갈 수 있는 단방향이다. 그렇기 때문에 제일 끝번째의 구조체를 건드리기 위해선 앞에서 순차적으로 접근해야하는 문제가 있다.
예를들어
```
1 -> 2 -> 3 -> 4 -> 5 -> 6
```
리스트가 있다고 가정할 때 5라는 데이터를 가진 구조체에 접근하고 싶으면 1->2->3->4->5 이런 순서로 접근해야한다.

배열처럼 [] 방식으로 접근할 수 없는 이유는 배열은 연속된 메모리 공간을 할당해서 [] 연산을 통해 배열의 시작 메모리 주소에 8byte (64비트) or 4byte (32비트) * index 만큼의 값을 더해주면 바로 접근이 가능하다.

하지만 리스트의 각 구조체는 동적할당을 통해 생성했기 때문에 메모리 공간 이곳저곳에 위치해있다. (운 좋게 연속적으로 할당될 순 있지만 보장할 수 있는가? 없다!)

그래서 등장한게 **Double linked list**인데 이건 유진님이 잘 설명해주실거다.

#### Head가 뭔데?
Head는 제일 처음의 구조체를 가르킨다. 자 그러면 제일 처음이라는건 어떻게 알아낼 수 있는가? 그걸 표시하기 위해서 존재하는게 Head다.

만약 우리가 SingleLinkedList 클래스를 만든다고 가정한다면 제일 처음 노드라는걸 어떻게 표현할지 고민해보도록 하자. 

#### 구조체
사실 위에서 구조체 구조체 했지만 다들 Node라고 부른다.