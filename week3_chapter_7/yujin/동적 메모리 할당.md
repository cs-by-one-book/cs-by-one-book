# 동적 메모리 할당

배열 등의 변수가 사용하는 메모리는 정적(static)이다.

이와 다르게 리스트 노드와 같은 존재는 동적이다.

이들은 필요에 따라 생기기도 하고 사라지기도 한다.

동적인 대상에 사용할 메모리를 힙에서 얻는다.



프로그램은 힙을 관리하는데 라이브러리 함수가 있어서 직접 작성할 필요는 없다.

c에는 malloc, free함수 가 있다.

힙 영역은 다음 그림과 같이 여러 블록으로 나누어져 있으며, 각 블록에 대한 크기와 다음 블록에 대한 포인터가 포함되어 있다.

![image-20211202021743892](https://raw.githubusercontent.com/yujin-kim-92/typora-image/main/img/image-20211202021743892.png)

시간이 지남에 따라 메모리 공간은 파편화(fragmentation)이 일어난다.

메모리를 모두 사용하진 않지만 너무 작은 가용 블록들만 남아서 요청받은 메모리를 돌려줄 수 없게 된 경우를 의미한다.

할당하지 않은 메모리를 해제하거나 해제된 메모리를 계속 사용하는 실수는 그림 7-17의 size와 next 필드를 오염시킬 수 있다. 

해당 오류는 size와 next가 필요한 연산이 실행되기 전까지는 문제가 들러나지 않기 때문에 발견하기 어렵다.

기술발전으로 필요 이상의 큰 메모리를 제공하는 경우가 있는데 이런 부가 비용을 줄이고 해당 관련 버그를 없애기 위해서 모든 메모리를 정적으로 할당해서 사용하는 편이 더 좋다.

# 더 효율적인 메모리 할당

![image-20211202022816498](https://raw.githubusercontent.com/yujin-kim-92/typora-image/main/img/image-20211202022816498.png)

7-18과 같이 노드를 위해서 다음 주소와 문자열이 저장된 주소를 저장하기 위한 부가 비용이 데이터에 비해서 큰 경우가 있다.

이러한 문제를 줄이기 위해서 노드와 문자열을 동시 할당 할 수 있다.

7-19 그림과 같이 노드에서 문자열을 참조하는 대신에 문자열을 직접 저장하는 것으로 부가비용을 줄일 수 있다.

![image-20211202173151948](https://raw.githubusercontent.com/yujin-kim-92/typora-image/main/img/image-20211202173151948.png)

# 가비지 컬렉션

자바나 자바스크립트 같은 언어에는 포인터가 없지만 직접 malloc이나 free를 하지 않으면서도 동적 메모리 할당을 지원한다.

이런 언어에는 malloc과 free 대신에 가비티 컬렉션(garbage collection)을 구현한다. 부분적으로 잘못된 포인터 사용에 대한 후회로 최근 가비지 컬렉션이 떠오르고 있다.

자바 같은 언어는 포인터 대신에 참조(reference)를 사용한다. 포인터를 추상화하여 비슷한 기능은 제공하지만 실제 메모리 주소는 노출하지 않는다.

가비지 컬렉션을 사용하는 언어에는 데이터 요소를 만들어내면서 이 요소가 사용할 메모리도 할당하는  new 연산자를 제공하는 경우가 자주 있다. 데이터 요소를 삭제하는 경우에 대응하는 연산자는 없다. 대신 런타임 환경이 변수 사용을 추적하여 더 이상 사용하지 않는 메모리를 자동으로 해지하는 다양한 방법이 있다. 그 중에서 변수가 참조하는 횟수를 추적하여 메모리를 참조하는 변수가 없을때 메모리를 해제하는 참조 카운팅 방법이 있다.

가비지 컬렉션도 트레이드 오프가 있다.

1.  프로그래머가 가비지 컬렉션을 제어할 수 없다는 점이다.
2.  프로그램이 중요한 일을 하는 도중에 가비지 컬렉션 시스템이 작동돼서 문제가 생기는 경우도 있다. 
3.  불필요한 참조가 남아서 메모리를 더 많이 사용하는 경우가 있다.
4.  불필요한 참조를 추적하는 작업 또한 실제로는 디버깅하기 어렵다.



# 이중 연결 리스트

단일 연결 리스트에서 delete를 수행하기 위해서는 삭제하고자 하는 바로 앞 원소를 찾아야한다. 이로 인해서 단일 연결 리스트의 delete는 상당히 느리다.

![image-20211202154713048](https://raw.githubusercontent.com/yujin-kim-92/typora-image/main/img/image-20211202154713048.png)![image-20211202154830396](https://raw.githubusercontent.com/yujin-kim-92/typora-image/main/img/image-20211202154830396.png)

이중 연결 리스트는 메모리를 더 사용하여 이러한 문제를 해결한 리스트이다. 단일 연결 리스트보다 노드의 부가비용은 2배가 되지만, delete시 노드를 앞에서부터 방문할 필요가 없어진다. => 공간/시간의 트레이드 오프

이중 연결 리스트의 장점은 리스트 전체를 방문하지 않아도 원하는 위치에 노드를 추가하거나 삭제할 수 있다.

![image-20211202155128036](https://raw.githubusercontent.com/yujin-kim-92/typora-image/main/img/image-20211202155128036.png)![image-20211202155138834](https://raw.githubusercontent.com/yujin-kim-92/typora-image/main/img/image-20211202155138834.png)

