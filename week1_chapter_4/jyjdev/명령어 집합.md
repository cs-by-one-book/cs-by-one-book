## 명령어 집합    

실행장치가 프로그램을 실행하기 위한 순서   

1.  프로그램 카운터가 가리키는 주소에서 명령어 읽어오기 

   (명령어 : 컴퓨터가 어떤 일을 해야 하는지 포함)   

2. 프로그램 카운터 증가   

3. 다시 해당 주소에서 명령어를 읽어오기   

4. 1~2번 과정 반복    



### 명령어 구성 방법         

#### (1) 3주소 명령어 구성    

- 필드 나누기   
  - 명령코드 / 피연산자 A / 피연산자 B / 결과 라는 4가지 필드로 나누는 방식   
  - 단점   
    - 피연산자 주소에 몇비트밖에 쓸수 없어서, 쓸모있는 크기의 메모리를 가리킬 수 X      
      - 64비트크기의 명령어를 사용해도 20비트 밖에 못쓰는데, Mib 처리만 가능
      - 최신 컴퓨터들은 GiB 이상 메모리를 쓸수 있기 때문에 비효율적    



- DRAM 주소 지정 기법 활용         
  - 주소 확장 레지스터를 두고 별도의 명령어를 사용해 상위 주소 지정    

    - 인텔에서 32비트 CPU로 4Gib이상의 메모리에 접근할 때 사용했던 방법 

      PAE - 물리주소확장        

  - 단점   

    - 주소 확장 레지스터에 값을 설정하는 시간 필요    
    - 메모리 영역을 모두 지정하려면 레지스터 설정이 여러번 필요   



- 3주소 명령어 구성의 가장 중요한 단점    

  - 세 메모리 위치(피연산자 A / 피연산자 B / 결과)를 한번에 지정하는 메모리 주소 접근을 사용하므로 각 메모리 블록이 각자 다른 장치에 존재      

    -> 연산 결과를 다른 연산에 활용하려면 해당 결과를 다른 메모리 장치로 보내기 위한 별도의 명령어 필요    

  - CPU 패키지와 핀 개수를 늘리지 않으려면 3개의 메모리 모두 같은 핀을 공유하고 다른 클록에 작동해야 함   

    -> 메모리 블록을 각자 다른 장치에 할당할 필요가 없음    



- 결국, 이러한 단점들을 극복하기 위해선, 한번에 한 메모리 블록에만 접근할 수 있다는 사실에 맞춰서 명령어 집합을 적절히 설계해야 함       

  -> 한번에 한 메모리 블록에만 접근하면 주소에 좀 더 많은 비트 활용 가능       



#### (2) 1주소 명령어 구성   

- 누산기 레지스터 활용   

  - 누산기는 ALU가 계산한 결과 저장    

  - 3주소 명령어 구성에선 피연산자 A와 피연산자 B 사이의 연산을 계산했다면,   

    1주소 명령어 구성에선 누산기에 있는 값과 메모리 위치에 있는 값의 연산 계산   

    ```python
    # 3주소 명령어 
    + , A, B, C
    
    C = A + B 
    
    # 1주소 명령어
    =, A
    +, B
    =, C
    
    A를 누산기에 저장
    B + 누산기값 을 누산기에 저장
    누산기 값을 C에 저장
    ```

    - 3주소 명령어에선 1개의 명령어를 사용하지만, 1주소 명령어에선 3개의 명령어 사용   
      - 위처럼 간단한 경우엔 더 복잡해보이지만, 연관된 주소가 3개가 넘어가면 다름   

    ```python
    # 각 주소마다 12비트, 명령어 4비트를 사용한다면,
    D = A + B + C
    
    # 3주소 명령어 
    중간 = A + B
    D = 중간 + C
    
    # -> (A,B,중간 + 명령어=40비트), (C,중간,D + 명령어=40비트) 총 80비트 필요
    
    # 1주소 명령어
    누산기 = A
    누산기 = 누산기 + B
    누산기 = 누산기 + C
    D = 누산기
    
    # -> (A,B,C,D) = 48비트 + (명령어 4개 = 16비트) = 64비트
    ```



### 주소 지정 모드  

- 누산기를 사용하면 3주소 명령어보단 훨씬 낫지만, 여전히 사용가능 주소가 충분 X         
- 속도 : 즉시 < 직접 < 간접    
  - 직접 주소 지정은 (명령어 1번), (메모리 데이터 로드 1번), 총 2번 메모리 접근 필요   
  - 간접 주소 지정은 총 3번 메모리 접근 필요     
- 총 4가지 모드가 있지만, 아래 3가지 모드와 달리 4번째 모드는 메모리와 관계없는 연산 표현   
  - `ex>` 시프트 연산     



#### 직접 주소 지정  

- 1주소 명령어 구성처럼 주소를 가리키는 방식    
- 주소가 명령어에 직접 들어가 있다는 뜻      



#### 간접 주소 지정   

- 명렁어에 피연산자 주소를 얻을 수 있는 메모리 위치를 가리키는 주소가 포함됨    
  - 더 많은 메모리 추가 가능    



#### 즉시 주소 지정 모드 

- 주소를 지정하는 것이 아니라, 직접 값을 지정하는 모드    
- 주소에 해당하는 비트를 그냥 값으로 간주    





### 조건 & 분기 명령어 

- 조건 코드   
  - `cca` 
    - 조건 코드 레지스터의 값을 누산기로 복사   
  - `acc`  
    - 누산기의 값을 조건 코드 레지스터에 복사    
- 분기 명령어    
  - 프로그램 카운터의 값을 변경할 수 있는 명령어    
    - 처음부터 끝까지 명령어를 모두 수행하는 것은 비효율적이므로           
  - 조건 코드에 대해 True 일때만 분기하는 방식으로 활용하면 더 유용    
    - 조건코드는 p181. 표 4-2 참고    
  - `pca`    
    - 프로그램 카운터의 값을 누산기로 복사   
  - `apc`    
    - 누산기의 값을 프로그램 카운터에 복사    



### 최종 명령어 집합    

- 주소지정모드(2비트) / 명령코드(4비트) / 주소(10비트)   
  - 주소지정모드+ 1주소 명령어 구성   
  - 16비트일 경우 위처럼 지정된다는 뜻    







