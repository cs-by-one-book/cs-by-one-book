## :pushpin: 브라우저 자바스크립트

- 브라우저에서의 자바스크립트   

  - 단일 스레드로 동작    

  - 동시성    

    - 단일 스레드에서의 동시성은 문제 발생 가능      

    -> 자바스크립트가 등장하고나서, 브라우저의 모습이 변화하여 자바스크립트의 용도도 변경되었기 때문  

    

    **ex**  자바스크립트 등장 시점엔, 사용자 입력에 대해 결과 리턴 될때까지 기다림   

    ```
    사용자 입력 받음 > 입력받은 데이터를 서버로 전송 > 유효성 검사 > 
    
    통과못하면, 에러 메세지 리턴 (트래픽 발생) > 
    
    통과하면 처리하여 결과 리턴   
    ```

    

    - 위와 같은 경우를 좀 더 효율적으로 처리하기 위해 자바스크립트 등장   

    ```
    자바스크립트를 사용하면서, 유효성 검사를 브라우저에서 가능해짐  
    
    -> 결과 기다릴 필요 X  & 에러 메세지를 리턴하기 위한 트래픽 발생 X   
    ```

    - 즉, 자바스크립트는 본래 더 빠른 사용자 피드백 & 트래픽 감소 목적으로 만들어졌기 때문에 + 처음엔 비동기 통신을 설계에 포함하지 않았어서 이러한 문제 발생  

  

  - 브라우저의 모습을 변화시킨 2가지 요소    

    1. DOM     

       - 문서 객체 모델      
       - DOM으로 인해 서버에서 HTML 페이지를 받는 대신, 웹 페이지 중 일부만 변경 가능해짐   

    2. XHR   

       (= XMLHttpRequest)          

       - 웹 브라우저와 웹 서버 간에 메소드가 데이터를 전송하는 객체 폼의 API
       - AJAX의 기반 
         - AJAX = 비동기 자바스크립트 + XML    
       - 기존의 **페이지 로드** 모델 :arrow_right:  백그라운드에서 브라우저 :left_right_arrow: 서버 통신    

    - 위와 같은 변화로 웹 페이지의 복잡도가 극적으로 증가   

      -> 자바스크립트 코드가 더 많이 작성   

      -> 주류 프로그래밍 언어로 급부상   

      -> 서버와의 비동기 통신에 극도로 의존하게 됨      

      -> 위에서 말했다시피, 자바스크립트는 이런 상황에 대비한 언어가 X    

      -> 단일 스레드 모델과 비동기 통신은 잘 맞지 않음   



- **이벤트 루프** 모델
  - 자바 스크립트 구현에 사용   
  - 사용자 이벤트에 응답하는 짧은 프로그램 실행 목적       



- **이벤트 큐**  

  - 이벤트 루프 모델에서의 실행할 작업을 넣어두는 곳   

  - 자바스크립트는 이벤트 큐에서 작업을 1번에 하나씩 꺼내서 처리   

    -> 단일 스레드이므로 인터럽트 불가   

    -> 이벤트가 큐에 추가되는 순서 제어 불가   



- 자바스크립트 실행 과정   

  - 작업 1  

    - 앨범 이름, 아티스트 이름 서버 전송   
    - 앨범 id 응답   

  - 작업 2 

    - 앨범 id 서버 전송  
    - 앨범 표지 url 응답   

  - 작업 1 요청 > 작업 2 요청 > 작업 2 응답(이벤트 큐에 함수 추가) > 작업 1 응답(이벤트 큐에 함수 추가)    

    - 위와 같이 작업이 진행된다면, 앨범 id 를 아직 응답 받지 않았는데, 작업 2 요청을 먼저 하는 경우 발생    

      -> 자바스크립트는 단일 스레드 + 서버와의 상호작용은 동시에 이루어지기 때문   

      즉, **프로그래머에겐 단일 스레드 모델 제공 + 내부에선 멀티스레드 활용**   

  - 해결 방법   

    - 작업 1 응답이 오면 작업 2를 호출하도록 코드 작성   

      즉, `작업 1의 콜백 함수`에 `작업 2 요청 코드` 작성     

    - But, 가독성이 나쁘므로 이에 대한 해결 방법은 `비동기 함수와 프로미스` 에서 설명   

