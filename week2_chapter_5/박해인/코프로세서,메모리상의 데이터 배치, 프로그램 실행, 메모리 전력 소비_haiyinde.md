# 5. 컴퓨터 아키텍처와 운영체제

[TOC]

#### 📌 코프로세서 (coprocessor)

> 보조 프로세서, 보조 처리기 : CPU의 기능을 보충하기 위해 사용되는 컴퓨터 프로세서

프로세스 코어(CPU)가 복잡한 회로로 이루어져 있기 때문에 몇 가지 연산을 코프로세서라는 더 단순한 회로에 위임하면 프로세서 코어가 공간을 더 확보할 수 있다.



✅ **직접 메모리 접근**(**DMA**, Direct Memory Access)

* 주 메모리 및 디스크 사이에서 DMA 장치가 CPU 대신 단순한 데이터 복사만을 담당한다.
* DMA 장치는 데이터를 복사하여 저장한 뒤에, 인터럽트 메커니즘을 통해 알려준다.
* 데이터 이동이 완료되었다는 단 한 번의 인터럽트만 발생하기 때문에 CPU는 데이터가 전송되는 동안 다른 작업을 수행할 수 있어서 효율적이다.



[참고]

↔ ✅ **프로그램 입출력** (**PIO**, Programmed Input/Output)

* DMA의 반대 개념 : 장치들 사이에 전송되는 모든 데이터가 중앙처리장치를 거쳐가는 방식.

* DMA는 PIO의 단점을 보완하기 위해 고안된 기능.

* 그러나 전송할 데이터가 많은 경우, 많은 양의 데이터의 이동으로 인한 부담이 커지는데 이러한 문제를 해결하기 위해 DMA를 사용한다.



#### 📌 메모리상의 데이터 배치

* 메모리에 담는 데이터는 '정적 데이터'

✅ **정적 데이터** (static data) : 메모리에 데이터를 올려놓은 상태에서 필요할 때 마다 데이터를 호출하여 사용하는 데이터



✅ **동적 데이터** (dynamic data)

* 서버에서 실시간으로 변환되어 적용되는 데이터, 프로그램 실행 전에는 크기를 알 수 없는 데이터
* 주로 정적 데이터가 차지하는 영역의 바로 위 영역에 쌓인다  === 힙(heap) 영역에 저장



✅ [그림 5-15] MMU가 없을 때 폰 노이만 구조와 하버드 구조의 전형적인 메모리 배치

<img src="코프로세서,메모리상의 데이터 배치, 프로그램 실행, 메모리 전력 소비_haiyinde.assets/image-20211111190645546.png" alt="image-20211111190645546" style="zoom: 33%;" />

* 차이 : 하버드 구조에서 명령어가 별도의 메모리에 존재한다.

* [참고] MMU(Memory Management Unit, 메모리 관리 장치) : CPU가 메모리에 접근하는 것을 관리하는 컴퓨터 하드웨어 부품, 가상 메모리 주소를 실제 메모리 주소로 변환





**✅ 프로그램의 메모리 사용 방법**

* 더 많은 데이터를 저장해야 할 경우 스택은 아래로 자라고, 힙은 위로 자란다
* 힙과 스택이 서로 충돌하지 않게 하는 것이 중요
* 마이크로컴퓨터에서는 MMU가 없는 경우가 많기 때문에 이런 메모리 배치를 자주 볼 수 있다
  * MMU가 쓰이는 경우에는 명령, 데이터, 스택이 각기 다른 물리적 메모리 페이지에 매핑되고, 필요에 따라 할당된 크기를 변경할 수 있다.

<img src="코프로세서,메모리상의 데이터 배치, 프로그램 실행, 메모리 전력 소비_haiyinde.assets/image-20211111191529740.png" alt="image-20211111191529740" style="zoom: 33%;" />



#### 📌 프로그램 실행

> 컴퓨터 프로그램의 여러 부분이 어떻게 함께 사용되는가?

✅ **링커** (linker, 링크 에디터 link editor)

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Linker.svg/1200px-Linker.svg.png" alt="링커 (컴퓨팅) - 위키백과, 우리 모두의 백과사전" style="zoom: 25%;" />

* 각 프로그램을 링크하기 편한 형식의 매개 파일(intermediate file)로 나누고 링커라는 특별한 프로그램을 사용해 여러 조각을 하나로 연결해 실행한다.
* **실행과 링크가 가능한 형식**(**ELF**, Executable and Linkable Format) : 현재 가장 유명한 매개 파일 형식



✅ **정적 링크** (static linking)

* 링크를 수행하면 컴파일 후 생성되는 최종 binary file (exe나 dll 등의 최종 목적 파일)에 묶이게 된다. 이것이 static link library
* 컴파일시 라이브러리가 함께 참조되어 실행파일과 함께 만들어진다.
* 실행에 필요한 모든 목적 코드를 연결시켜 실행파일이 만들어진다. 
* 하지만, 정적 링크를 사용하면 같은 라이브러리 코드가 여러 실행 파일에 반복적으로 들어가서 메모리를 낭비한다. → 동적 링크 발명



✅ **동적 링크** (dynamic linking)

* 공유 라이브러리를 사용하는 동적 링크
* binary와 link가 따로 존재한다.
* 실행시에 해당 라이브러리가 연결되어 실행된다.
* 프로그램 실행 도중에 필요한 목적코드를 필요시마다 연결하도록 실행파일이 만들어진다.
* MMU가 여러 프로그램이 같은 라이브러리를 공유할 수 있게 해준다.
* 라이브러리 함수를 작성할 때 호출하는 프로그램의 스택과 힙을 사용하도록 함수를 설계해야 한다.



✅ **진입점** (entry point)

* 프로그램의 첫 번째 명령어가 위치한 주소
* 실제 프로그램이 실행될 때 가장 먼저 실행되는 명령어는 아님



✅ **런타임 라이브러리** (runtime library)

* 프로그램을 이루는 모든 부분이 하나로 합쳐져서 실행파일을 이룰 때 런타임 라이브러리가 추가된다.
* 하나의 라이브러리를 여러 프로그램이 사용했다면 각 프로그램은 같은 라이브러리를 참조하므로 메모리 절약
* 런타임 라이브러리의 명령어가 먼저 실행 → 진입점의 명령어 실행
  * 동적 라이브러리 파일을 찾지 못하면 runtime error 발생
* 메모리 설정을 책임진다. 스택과 힙 영역을 설정.
* 정적 데이터에 위치한 데이터의 초깃값 설정





#### 📌 메모리 전력 소비

✅ **전력 측면에서의 메모리**

* 데이터를 메모리에서 옮기면 전력이 소비된다. 모바일 장치에서는 전력 소비가 중요하다.
* 코드를 작성할 때도 전력 소비와 성능 사이에서의 균형을 잡아야 한다.
